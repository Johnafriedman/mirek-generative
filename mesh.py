# -*- coding: utf-8 -*-
"""Mesh.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10HMUQeTcNtXySy3CYzsg1DJPbTAsrV2b
"""


from PIL import Image, ImageDraw, ImageFilter, ImageChops
from PIL.ImageTransform import MeshTransform
import numpy as np
import random

import sys

from generative.utilities import make_mask, make_transparent, draw_mesh
from generative.transforms import create_randomized_aligned_mesh


IN_COLAB = 'google.colab' in sys.modules
test_mesh = False


use_mask = True
layers = 2
files = 3
shapes = 4
radius = 5
do_blur_prob = .4 

max_fill_alpha = 255
min_fill_alpha = 0
max_fill_red = 255
min_fill_red = 0
max_fill_green = 255
min_fill_green = 0
max_fill_blue = 255
min_fill_blue = 0

max_outline_alpha = 255
min_outline_alpha = 0
max_outline_red = 255
min_outline_red = 0
max_outline_green = 255
min_outline_green = 0
max_outline_blue = 255
min_outline_blue = 0

source_folder = '/content/' if IN_COLAB else 'input/'

if test_mesh:
  image_path = 'grid_image.png'
else:
  image_path = 'Rhythms_Circle_DataReferenceSet_1982_2.png'
##  image_path = 'abstract_artwork_with_neon1.png'
##  image_path = 'rhythms_entropic_heavens_waves_continue_v10.png'
##  image_path = 'myanmar_tm5_2004349_lrg.jpg'
##  image_path =  'PXL_20240906_152258909.jpg'

def invert(image):
# Create a mask with a white circle on a black background
  mask = Image.new('L', image.size, 0)
  draw = ImageDraw.Draw(mask)

  # Define the circle's center and radius
  center_x = image.width // 2
  center_y = image.height // 2
  radius = min(center_x, center_y) // 2  # Example: half of the smaller dimension

  # Draw a white circle on the mask
  draw.ellipse((center_x - radius, center_y - radius, center_x + radius, center_y + radius), fill=255)

  # Invert the circular region of the image
  inverted_image = ImageChops.invert(image)
  image.paste(inverted_image, mask=mask)
  
# return the blurred image
  return(image)
  

def blur(image, x, y, width, height, radius, fill, outline, outline_width, do_blur):

  # Apply Gaussian Blur

  mask = Image.new('L', (width, height), 0)

# Create a draw object for the mask
  draw = ImageDraw.Draw(mask)

  # Define the bounding box for the ellipse
  bounding_box = (0, 0, width, height)  # Adjust as needed

  # Draw the ellipse on the mask (white color fills the ellipse)
  draw.ellipse(bounding_box, fill=255)

  # Apply the mask to the image
  # image.putalpha(mask)
  
  cropped = image.crop((x,y,x+width,y+height))

  if do_blur:
    blurred_image = cropped.filter(ImageFilter.GaussianBlur(radius))
  else:
    blurred_image = cropped
  overlay = Image.new('RGBA', cropped.size, (0,0,0,0))
  odraw = ImageDraw.Draw(overlay)    
  odraw.ellipse(bounding_box, fill, outline, outline_width)
  blurred_image = Image.alpha_composite(blurred_image, overlay)
  # image.paste(blurred_image,(dx,dy), mask)



# return the blurred image
  return(blurred_image, mask)


# Open the image
input_path = f"input/{image_path}"

for file in range(0,files):
  image = Image.open(input_path)
  image = image.convert('RGBA')

  min_width = image.width * .1
  min_height = image.height * .1
  max_width = image.width * .3
  max_height = image.height * .3

  min_dx = image.width * .1
  min_dy = image.height * .1
  max_dx = image.width * .8
  max_dy = image.height * .8

  im = make_transparent(image, 128)
  for _ in range(0, layers):
    # Apply the mesh transform
    #mesh = make_mesh(3,im)
    mesh = create_randomized_aligned_mesh(3,4,im.width,im.height)
    # Create a new image with the mesh
    out = im.transform(im.size, MeshTransform(mesh))
    mask = out if use_mask else None
    #draw the transformed image on the original using a mask
    image.paste(out, None, mask)

    for shape in range(0,shapes):

      width = int(random.uniform(min_width, max_width))
      height = int(random.uniform(min_height, max_height))
      sx = int(random.uniform(min_dx, max_dx))
      sy = int(random.uniform(min_dy, max_dy))
      if random.random() > .5:
        dx = int(random.uniform(min_dx, max_dx))
        dy = int(random.uniform(min_dy, max_dy))
      else:
        dx = sx
        dy = sy

      fill_alpha = int(random.uniform(min_fill_alpha, max_fill_alpha))  

      outline_alpha = int(random.uniform(min_outline_alpha, max_outline_alpha))     
    
      fill_red = int(random.uniform(min_fill_red, max_fill_red))

      outline_red = int(random.uniform(min_outline_red, max_outline_red))   

      fill_green = int(random.uniform(min_fill_green, max_fill_green))  

      outline_green = int(random.uniform(min_outline_green, max_outline_green))   
    
      fill_blue = int(random.uniform(min_fill_blue, max_fill_blue))

      outline_blue = int(random.uniform(min_outline_blue, max_outline_blue)) 

      bounding_box=(0,0,width,height)
      do_blur = random.random() > do_blur_prob
      (out, mask) = blur(image, sx, sy, width, height, 5, (fill_red, fill_green, fill_blue, fill_alpha), (outline_red, outline_green, outline_blue, outline_alpha), 2, do_blur)
      image.paste(out, (dx,dy), mask)

  if test_mesh:
    draw_mesh(mesh, image)
    
  filename = f"output/mesh_image{file}.png"
  image.save(filename)
  image.show(filename)

